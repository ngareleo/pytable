import numpy as np
from enum import Enum
from typing import TypeVar, Type, Any
from functools import reduce
from pytable.utils import cutAtSpace, notNone

type T = TypeVar("T", str, int, float)
type Row = list[str]


class Alignment(Enum):
    CENTER = "^"
    RIGHT = ">"
    LEFT = "<"


class Col:
    """
    Representation of a table column. Columns don't need to be declared expliticly.
    They can be autogenerated by including the labels on the head of the body.
    """

    default_max_width = 16
    default_align = Alignment.LEFT

    def __init__(
        self,
        label: str,
        width: int = None,
        max_width: int = None,
        align: Alignment = None,
    ) -> None:
        """
        Create a table column.
        Properties:

        `label` -- The label to display on the header.
        `width` -- Width of the column. If width is not provided it will not be wider than max-width.
        `max_width` -- Max width of a single column, Default behavior is wrapping to next line.
        `align` -- The alignment of text in the column.
        """
        self.label = label
        # Using notNone to pick up defaults during runtime
        self._max_width = notNone(max_width, Col.default_max_width)
        self._align = notNone(align, Col.default_align)
        self._width = notNone(width, self._max_width)

    @property
    def align(self) -> str:
        return self._align.value

    @property
    def width(self):
        return self._width

    @width.setter
    def width(self, v):
        self._width = min(self.max_width, v)

    @property
    def max_width(self):
        return self._max_width

    @max_width.setter
    def max_width(self, v):
        if self._width == self._max_width:
            self._width = v
        self._max_width = v


class Header:
    def __init__(self, cols: list[Row]) -> None:
        self.cols = cols


class Body:
    def __init__(self, rows: list[Row] = None) -> None:
        self.rows = rows

    def get_col_sizes(self, cols: list[Col]) -> list[Col]:
        pass

    def remove_first_row(self) -> None:
        self.rows.pop(0)


class TableConfigs:
    """These are configurations that apply globally to all entities. They can be edited by using `Table.config(**kwargs)`"""

    headerless = False
    max_width = None  # Initially all cols can stretch as much
    align = Alignment.LEFT


class Table:
    """Internal implementation of table"""

    default_limit = 50

    def __init__(
        self,
        columns: list[Col] = None,
        body: Body = None,
        limit=default_limit,
        **configs,
    ) -> None:
        self.columns = columns
        self.body = body
        self.limit = limit
        self.config = TableConfigs()
        self.edit_global_table_configs(**configs)

    def edit_global_table_configs(self, **configs):
        for key, value in configs.items():
            if (
                key.startswith("_")
                or key.endswith("_")
                or key not in self.config.__dir__()
            ):
                raise ValueError(f"Config {key} does not exist")

            if key in Col.__dict__.keys():
                self._apply_global_col_config(key, value)
            self.config.__setattr__(key, value)

    def _apply_global_col_config(self, k: str, v: Any):
        if self.columns:
            for col in self.columns:
                col.__setattr__(k, v)

    def _render_horizontal_border(self):
        if not self.columns:
            raise ValueError("Headers not defined")

        # Always called after self.draw()
        # No checks required
        sized_horizontal_lines = [
            "{:-<{size}}+".format("", size=col.width) for col in self.columns
        ]
        return "".join(["+"] + sized_horizontal_lines)

    def _render_header_content(self):
        if not self.columns:
            raise ValueError("Headers not defined")

        return "".join(
            ["|"]
            + [
                "{:{fill}{align}{size}}|".format(
                    col.label, fill=" ", size=col.width, align=col.align
                )
                for col in self.columns
            ]
            + ["\n"]
            + ["+"]  # start of the bottom border that uses = instead of -
            + ["{:=<{size}}+".format("", size=col.width) for col in self.columns]
        )

    def _render_single_row(self, row: Row):
        drawable_cells = []
        rest_cells = []
        for rule, cell in zip(self.columns, row):
            drawable, rest = cutAtSpace(cell, rule.width)
            drawable_cells.append(drawable)
            rest_cells.append(rest)

        # Look ahead if we need next line
        will_not_execute_next = (
            reduce(lambda a, b: a.strip() + b.strip(), rest_cells) == ""
        )
        line = "".join(
            ["|"]
            + [
                "{:{fill}{align}{size}}|".format(
                    cell, fill=" ", size=col.width, align=col.align
                )
                for col, cell in zip(self.columns, drawable_cells)
            ]
            + ["\n"]
        )

        if will_not_execute_next:
            return line + self._render_horizontal_border()
        else:
            return line + "\n" + self._render_single_row(rest_cells)

    def _render_body(self):
        if not self.columns:
            raise ValueError("Headers not defined")

        if not self.body:
            raise ValueError("body not provided")

        return [self._render_single_row(row) for row in self.body.rows]

    def render_table(self):
        header = "".join(
            [self._render_horizontal_border(), "\n", self._render_header_content()]
        )
        print(
            self._render_horizontal_border() if self.config.headerless else header,
            *self._render_body(),
            sep="\n",
        )

    def get_cols_configs_from_head(self):
        if not self.body:
            raise ValueError("body not provided")

        [head, *_] = self.body.rows
        self.columns = [Col(label=col) for col in head]
        for w, col in zip(self._get_col_widths(), self.columns):
            col.width = w

        # remove the first col from body
        self.body.remove_first_row()

    def _get_col_widths(self) -> list[int]:
        """Assumes the first array is the header"""
        cells = np.transpose(self.body.rows)
        return [len(max(col, key=len)) + 3 for col in cells]
